data List X = nil  : (List X)
            | cons : X -> (List X) -> (List X).

data Zero =.

data Unit = unit : Unit.

append : (List X) -> (List X) -> (List X)
append nil         ys = ys;
append (cons ax xs) ys = cons ax (append! xs ys);

interface Send X = send : X -> Unit.

interface Receive X = receive : X.

interface Abort = aborting : Zero.

map : {A -> B} -> (List A) -> (List B)
map f nil = nil;
map f (cons x xs) = cons (f! x) (map! f xs);

bind : X -> {X -> Y} -> Y
bind bx f = f! bx;

abort : [Abort]X
abort = bind! (aborting!) ({()});

semi : X -> Y -> Y
semi   x    y =  y;

sends : (List X) -> [Send X]Unit
sends xs = semi! (map! send xs) unit;

{-
Does not work; infinite recursion generates unmatched receives.
catter : [Receive (List X)](List X)
catter = bind! (receive!) ({ nil -> nil | cxs -> append! cxs (catter!) });
-}

catter : [Receive (List X)](List X)
catter 0 = nil;
catter n = bind! (receive!) ({ nil -> nil
                             | cxs -> append! cxs (catter! (minus! n 1)) });

pipe : [Send X]Unit -> [Receive X]Y   -> [Abort]Y
pipe         _               y         =     y;
pipe        unit             _         =   abort!;
pipe   [send px -> s]   [receive -> r] =  pipe! (s! unit) (r! px);

fib : (List (List Int))
fib = cons
          (cons 1 nil)
       (cons
	  (cons 1 (cons 2 nil))
       (cons
          (cons 3 (cons 5 (cons 8 nil)))
        nil));

sender : [Send (List Int)]Unit
sender = sends! (fib!);

length : (List X) -> Int
length nil = 0;
length (cons x xs) = plus! 1 (length! xs);

main : [Abort](List Int)
main = pipe! (sender!) (catter! (length! (fib!)));
