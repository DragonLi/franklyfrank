{- Testing out comments. -}
data Nat = zero : Nat
         | suc : Nat -> Nat.

data List X = nil  : (List X)
            | cons : X -> (List X) -> (List X).

append : (List X) -> (List X) -> (List X)
append nil         ys = ys;
append (cons x xs) ys = cons x (append! xs ys);

plus : Nat -> Nat -> Nat
plus zero m = m;
plus (suc n) m = suc (plus! n m);{-
plus [?c -> k] [t] = let x = c! in plus (k! x) t!
plus [t] [?c -> k] = let x = c! in plus t! (k! x)

# plus (h (suc zero)) zero
# -->
# plus comp zero


-}

interface State X = get : X | put : S -> Unit.

interface Receive X = receive : X.

fmap : {A -> B} -> List -> List
fmap f nil = nil;
fmap f (cons x xs) = cons (f! x) (fmap! f xs);

bind : X -> {X -> Y} -> Y
bind x f = f! x;

{- {- {- p[ef[##'####'##esaojdknsafoewowowo {{{{{a-
pi : {[]Int}
pi = 3.142 ##~~~ Ã¼
-}
g x y = x + y

f x = { y -> plus x y }
-}
main = {f! 42}
-}

catter : [Receive (List X)](List X)
catter = bind! (receive!) ({ nil -> nil | xs -> append! xs (catter!) });

some = { x -> x };

runState : X -> [State X]Y    -> Y
runState   x    (put x' -> k) =  runState x' (k! unit);
runState   x    [get    -> k] =  runState x  (k! x);
runState   x          x       =  x;
{-

cont
hs

runState 42 (h 3)
=
h 3 (cont = id :: cont, hs = (runState 42 _)::hs)


runState 42 (h 3)
-->
runState 42 (h 3)

main = runState


-}
